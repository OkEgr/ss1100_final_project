import numpy as np
# Note: Students might need to install matplotlib if they don't have it
# pip install matplotlib
import matplotlib.pyplot as plt


# Generative AI Disclosure:
# The logic for np.dstack, calibration formulas, and image saving was
# adapted from suggestions generated by Gemini and ChatGPT.

def load_and_combine_bands(red_file, green_file, blue_file):
    """
    Loads the raw R, G, and B band data from CSV files, ensures they are of
    the same dimensions with np.stack, and combines them into a single RGB image.
    """

    try:
        # Tries to load data directly
        r_data = np.loadtxt(red_file, delimiter=',')
        g_data = np.loadtxt(green_file, delimiter=',')
        b_data = np.loadtxt(blue_file, delimiter=',')

        # Stack the arrays into a 3D image
        combined_image = np.dstack((r_data, g_data, b_data))
        return combined_image

    except Exception as e:
        # Corrects for value error if header present
        r_data = np.loadtxt(red_file, delimiter=',', skiprows=1)
        g_data = np.loadtxt(green_file, delimiter=',', skiprows=1)
        b_data = np.loadtxt(blue_file, delimiter=',', skiprows=1)

        # The first column contains row numbers (indexes), not pixel data.
        # We use slicing [:, 1:] to remove the first column and keep the rest.
        r_data = r_data[:, 1:]
        g_data = g_data[:, 1:]
        b_data = b_data[:, 1:]

        # Stack the arrays into a 3D image
        combined_image = np.dstack((r_data, g_data, b_data))
        print(f"Error loading files: {e}")
        print("Attempting to delete header labels...")
        return combined_image


def convert_radiance_to_reflectance(rgb_image, k=0.8, b=0.1):
    """
    Converts radiance values to reflectance.
    """
    # YOUR CODE HERE
    # Formula: Reflectance = k * Radiance + b
    reflectance = k * rgb_image + b

    # Clip values to ensure they stay within physical limits [0.0, 1.0]
    reflectance = np.clip(reflectance, 0.0, 1.0)
    return reflectance


def rescale_to_8bit(reflectance_image):
    """
    Converts the floating point reflectance values to 8-bit integers (0-255).
    """
    # YOUR CODE HERE
    # 1. Scale 0.0-1.0 up to 0-255
    scaled_image = reflectance_image * 255

    # 2. Convert to 8-bit unsigned integers
    return scaled_image.astype(np.uint8)


def save_image(image, filename):
    """
    Saves the image to a file.
    """
    # YOUR CODE HERE
    # Hint: Use plt.imsave
    plt.imsave(filename, image)


def main():
    """
    Main function to process the remote sensing data.
    """
    # File paths for the CSV data
    red_file = 'red.csv'
    green_file = 'green.csv'
    blue_file = 'blue.csv'

    # Task 1: Load and combine bands
    raw_image = load_and_combine_bands(red_file, green_file, blue_file)

    if raw_image is not None:
        print("Successfully loaded and combined image bands.")

        # FIX: Check if data needs conversion.
        # If the maximum value is > 1, the data is likely already in 0-255 format.
        # In this case, we skip the destructive radiance-to-reflectance conversion.
        if np.max(raw_image) > 1.0:
            print("Notice: Input data appears to be already scaled (0-255). Skipping radiance conversion.")
            final_image = raw_image.astype(np.uint8)
        else:
            # "Check Plus" Tasks (Only run if data is raw radiance < 1.0)
            # Task 2: Convert to reflectance
            reflectance_image = convert_radiance_to_reflectance(raw_image)
            if reflectance_image is not None:
                print("Successfully converted to reflectance.")

            # Task 3: Rescale to 8-bit
            final_image = rescale_to_8bit(reflectance_image)
            if final_image is not None:
                print("Successfully rescaled to 8-bit.")

        # Task 4: Visualize and save the final image
        if final_image is not None:
            plt.figure(figsize=(10, 6))
            plt.imshow(final_image)
            plt.title("Final Processed Image")
            plt.axis('off')
            plt.show()
            save_image(final_image, 'final_image.png')
            print("Saved final image to final_image.png")


if __name__ == "__main__":
    main()